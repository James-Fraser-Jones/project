\documentclass[11pt,a4paper,notitlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage{minted}
\begin{document}

\title{The lambda Calculus and its applications in functional Programming}
\author{James Fraser-Jones}
\date{January 2018}
\maketitle

\tableofcontents

\begin{abstract}
Abstract goes here.
\end{abstract}

\section{Motivation}
\section{The lambda Calculus}
The lambda Calculus is a model of computation. lambda \textit{``terms''} that are produced using this model will always either represent a computation to be performed, or the result of performing a previous computation. Frequently, the result of performing a step of computation \textit{is} another computation. The process of reducing a term to its simplest form is exactly the process of performing the entire computation that the original term was expressing and the resulting term then represents the result of this computation. For any lambda term, it is in its simplest form when it cannot be further reduced.

\subsection{Introduction}
The valid Syntax to represent any possible valid lambda term defined recursively by the following formula:
$$ Term = Lit\;|\;Var\;|\;\lambda Var.Term\;|\;Term\;Term$$
\textit{``Literals''} ($Lit$) can be any piece of information that we might wish to manipulate and/or produce in the process of computation. For example, numbers, strings of characters, or boolean truth values.
\\\\
lambda \textit{``Abstractions''} ($\lambda Var.Expr$) are functions which take \textit{one} term as input and output another one as output. functions contain two pieces of information. They contain the term that will be output when it is given an input term. They also contain a variable name ($Var$) which is used within the output term as a reference to the input term. This is necessary because (unless the output term is a constant) it will contain instances of the input term which reflect the fact that the output term is generated by manipulating the input term in a certain way. However, the form of the output term is defined before the function receives the input term, hence a variable name must be used as a reference until the input term can be fed in as input to the function.
\\\\
\textit{``Applications''} ($Expr\;Expr$) are terms which are composed of two other terms. The term on the left will be \textit{applied} to the one on the right. If the term on the left is a function, the one on the right can be fed into it as an input term through a process called Beta reduction. The effect of this process is that the function on the left loses its $\lambda$ and its variable and is then comprised entirely from its output term. The function on the right is then substituted into this term in the places where the original function's variable is free (the variable is not free in any part of the output term that is inside the body of another abstraction which bound the same variable name).
\\\\
Effectively, Abstractions are just for creating functions that wait for an input Term. Applications are for resolving functions by feeding them an input Term to transform them into a new Term. literals are just Values with some semantic meaning associated with them that we might wish to manipulate using functions to get new Values. And variables allow us to express the general form of functions without the requirement that an input Term be fed to them first.
\\\\
If, for example, we say that literals are Integers and variable names are denoted by Strings, lambda terms can be recursively defined using the following Haskell code:
\begin{minted}{haskell}
type Name = String

data Term
  = Lit Int
  | Var Name
  | Lam Name Term
  | App Term Term
\end{minted}
Using the same example, I'll give some examples of valid lambda terms:
$$ 1,\; x,\; \lambda x . x+1,\; (\lambda x . x+1) \; 1 $$
Which roughly correspond to the following Haskell expressions: (except, by default, $(+)$ isn't defined for our Term data type)
\begin{minted}{haskell}
Lit 1
Var "x"
Lam "x" ((Var "x") + (Lit 1))
App (Lam "x" ((Var "x") + (Lit 1))) (Lit 1)
\end{minted}
In the last example, this lambda term can be reduced down to $1+1$ which can then be further reduced using arithmetic (or in the context of programming, a processor instruction) to $2$.
\\\\
In fact, Haskell itself has a feature called ``anonymous functions'' (they are anonymous because they don't have names associated with them) which correspond directly to the idea of lambda abstractions. literals in Haskell are just values from its basic types (such as Int) and application works in Haskell the same way it does in lambda Calculus.
\\\\
Hence we can test the execution of $(\lambda x . x+1) \; 1$ without even declaring any new data types, we need only type the following line into GHCI:
\begin{minted}{haskell}
(\x -> x+1) 1
\end{minted}
Which is internally converted to ($1+1$) and then returned as the irreducible expression:
\begin{minted}{haskell}
2
\end{minted}
Note that Haskell's syntax is slightly different from the syntax of lambda Calculus so the ($\lambda$) is replaced with ($\backslash$) and the  $(.)$ is replaced with $(\rightarrow)$

\subsection{Important Properties}
Here, we will discuss a few subtle yet important properties of the lambda Calculus that make it very flexible and powerful as a tool for expressing computations.

\subsubsection{First-Class functions}
Traditionally, programming (and even hardware architecture) has had two very basic and fundamental concepts at its core: Data and Control. Data is stored in memory and referenced using variables and functions execute sequences of code in order to "Control" (i.e. manipulate) these variables in a useful way. On a more abstract level, variables are objects to be manipulated and functions are \textit{actions} that we can perform using those objects, to make new objects.
\\\\
The lambda Calculus uses the two ideas I've mentioned above in such a way as to imply that that both concepts are effectively equivalent. That is, variables can be functions and vice versa. This is evident in the fact that, within the lambda calculus, variables are simply terms, as are functions. Since functions take terms as input and generate them as output, it is entirely possible for them to take other functions as input and generate new functions as output. Within programming languages, objects which can be passed to and from functions are called "First Class". In many programming languages, only variables and Data Structures are first class but, because of this fundamental part of lambda Calculus, functional programming languages have first class functions which allows them a great deal more flexibility and expressiveness when tackling computational problems.
\\\\
Suppose we want to write a function that works in the following way:
$$g(x, y, f) = f(x,y)$$
$$g(1, 2, +) = +(1,2) = 1 + 2 = 3$$
$$g(4, 7, *) = *(4,7) = 4 * 7 = 28$$
In this instance, the mathematical operator $f$ being input to the function $g$ is, itself, a function that takes in two numbers and produces a third number. Hence $g$ can only be written in a language that supports first-class functions.
This can be achieved in Haskell in the following way:
\begin{minted}{haskell}
g :: Int -> Int -> (Int -> Int -> Int) -> Int
g x y f = f x y
\end{minted}
Then we can test the function in GHCI:
\begin{minted}{haskell}
g 1 2 (+)
g 4 7 (*)
\end{minted}
Which return 3 and 28, respectively.
\\\\
On a semantic level, the equivalence between variables (Objects) and functions (Actions) might not be particularly intuitive but there are perspectives on this which make sense.
\\\\
A variable is just a special function in the sense that it doesn't take an term as input and, hence, immediately returns an output term: itself.
\\\\
Likewise, a function is just a variable whose semantic meaning happens to describe the process by which \textit{other} terms may be manipulated.

\subsubsection{Currying}
We can use the previous section's example to illustrate another interesting property of the lambda Calculus.
\\\\
As we know, functions in the lambda Calculus take one lambda term as input and produce another one as output. There seems to be a problem with this definition, however, because even quite basic functions such as the addition operator $(+)$ are required to take \textit{more} than one input term in order to produce an output term. In the case of addition, it must take \textit{two} numbers as input before it is able to produce the result of the sum of these numbers. The solution to this issue relies on the fact that functions in the lambda Calculus are first class and, specifically, the fact that we can return functions as the output term from other functions.
\\\\
Suppose that we have the addition operator $(+)$ and we only provide it with one number, for example: $5$. What sensible term could be returned as the output term?
\\\\
In order to ensure that we get the behavior we expect, we should be able to feed whatever term is produced with a second number, say $2$, and this should then return the value of $5+2$.
\\\\
The implication here is that, the output term produced from feeding $(+)$ with $5$ is a \textit{function} since it then is required to take in another number as input. And in order for this function to behave as we expect, it can only be the function "add5" which is the function that takes in a number and adds $5$ to it.
\\\\
So to be clear:
$$+(5) = add5$$
$$add5(2) = 5 + 2$$
This idea is very powerful because it means that we can create and use functions in an extremely flexible way. Effectively, the addition operator is a function which can, itself, create an \textit{infinite} number of functions, each of which will add a specific number to whichever number it is subsequently provided with.
\\\\
Technically speaking, addition as a mathematical operation is a mathematical function that is defined (for all ``Real'' numbers, $\mathbf{R}$) as:
$$+:(\mathbf{R},\mathbf{R}) \rightarrow \mathbf{R} $$
In order to convert this function into a form that is expressible as a lambda term we must \textit{"Curry"} it by transforming it into the following, equivalent, function:
$$curry(+):\mathbf{R} \rightarrow (\mathbf{R} \rightarrow \mathbf{R})$$
If we then also specify that, by default, the arrow operator ($\rightarrow$) is right-associative then we get the following:
$$curry(+):\mathbf{R} \rightarrow \mathbf{R} \rightarrow \mathbf{R}$$
Which is effectively the \textit{type} of the addition function in Haskell as
\begin{minted}{haskell}
:t (+)
\end{minted}
returns
\begin{minted}{haskell}
(+) :: Num a => a -> a -> a
\end{minted}
In this case, the class constraint on the type signature given by ``$Num\;a \Rightarrow$'' merely specifies that ``a'' is a number, which is effectively the same thing that $\mathbf{R}$ specifies in the above definition of the addition operator.
\\\\
Although function Currying may seem like a way to avoid the inherent problem with functions that take multiple inputs in a system that allows only one, the fact that we can use and manipulate the \textit{intermediate} functions produced by curried functions really means that curried functions are more expressive and more versatile than their uncurried counterparts with no real drawbacks.

\subsubsection{Church Encoding and Data Structures}
lambda Calculus gives us three of the the things that we would expect from most programming languages upfront: literals, variables and functions. But it doesn't give us another very important feature: Data Structures.
\\\\
In most programming languages, several data structures are implemented by default in order to allow us to manipulate data in a structured and organized way.
\\\\
In order to be able to use lambda Calculus as the basis of a functional programming language, we need to know that we can implement Data Structures using it. Since, all terms in lambda Calculus are functions, this means that we need to be able to create a function which is able to take in other terms (i.e. the data that we want to put into the data structure)

\subsection{Reduction Methods}
\subsubsection{Free variables and variable Capture}
\subsubsection{Alpha}
\subsubsection{Beta}
\subsubsection{Eta}
\subsection{Evaluation Strategies}
\subsubsection{The Beta Cube}
\subsection{Example Applications}
\subsubsection{Relation to Imperative Programming}
\subsubsection{Relation to Algebra}
\section{Simply Typed lambda Calculus}
\subsection{Type Checking}
\section{The lambda Cube}
\subsection{Polymorphism}
\subsection{Type Constructors}
\subsection{Dependent Types}
\section{System F}
\section{System F$\omega$}
\section{The Calculus of Constructions}

\end{document}
